<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Chen's blog</title><link>http://blog.binchen.org/</link><description>Linux, Programming, Emacs</description><atom:link href="http://blog.binchen.org/rss.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Tue, 26 May 2020 05:48:09 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Hardcore spell checking in Emacs</title><link>http://blog.binchen.org/posts/hardcore-spell-checking-in-emacs.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
This article is not introduction of Emacs spell checking basics. It requires deep knowledge of Emacs Lisp and Fly Spell.
&lt;/p&gt;

&lt;p&gt;
You could read my article &lt;a href="https://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html"&gt;What's the best spell check setup in emacs&lt;/a&gt; for basic knowledge.
&lt;/p&gt;

&lt;p&gt;
This article introduces &lt;b&gt;new techniques to make Fly Spell more powerful and faster&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
The CLI program aspell and hunspell can only parse plain text. They don't know any programming language syntax.
&lt;/p&gt;

&lt;p&gt;
Fly Spell feeds the output of CLI program into its own Lisp predicate named &lt;code&gt;flyspell-generic-check-word-predicate&lt;/code&gt; whose default value is nil.
&lt;/p&gt;

&lt;p&gt;
When executing &lt;code&gt;(flyspell-mode 1)&lt;/code&gt;, the &lt;a href="https://github.com/emacs-mirror/emacs/blob/c6fb86b40bebf597fccbe4eba58ceea83bd9700f/lisp/textmodes/flyspell.el#L655"&gt;per mode predicate is assigned&lt;/a&gt; to &lt;code&gt;flyspell-generic-check-word-predicate&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
For example, you can run &lt;code&gt;(get major-mode 'flyspell-mode-predicate)&lt;/code&gt; to get predicate of current major mode, &lt;code&gt;(get 'web-mode 'flyspell-mode-predicate)&lt;/code&gt; to get predicate of &lt;code&gt;web-mode&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The predicate is a simple function without parameter. Here is my predicate for &lt;code&gt;web-mode&lt;/code&gt;,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun my-web-mode-flyspell-verify ()
  "Fly Spell predicate of `web-mode`."
  (let* ((font-face-at-point (get-text-property (- (point) 1) 'face))
         rlt)
    ;; If rlt is t, the word at point is POSSIBLY a typo, continue checking.
    (setq rlt t)
    ;; if rlt is nil, the word at point is definitely NOT a typo.
    ;; (setq rlt nil)
    rlt))
;; Attach my predicate to `web-mode`
(put 'web-mode 'flyspell-mode-predicate 'my-web-mode-flyspell-verify)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
If you read code of &lt;a href="https://github.com/emacs-mirror/emacs/blob/c6fb86b40bebf597fccbe4eba58ceea83bd9700f/lisp/textmodes/flyspell.el#L435"&gt;flyspell-prog-mode&lt;/a&gt;, you will find it set &lt;code&gt;flyspell-generic-check-word-predicate&lt;/code&gt; to its own predicate &lt;code&gt;flyspell-generic-progmode-verify&lt;/code&gt;,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defvar flyspell-prog-text-faces
  '(font-lock-string-face font-lock-comment-face font-lock-doc-face)
  "Faces corresponding to text in programming-mode buffers.")

(defun flyspell-generic-progmode-verify ()
  "Used for `flyspell-generic-check-word-predicate' in programming modes."
  (unless (eql (point) (point-min))
    ;; (point) is next char after the word. Must check one char before.
    (let ((f (get-text-property (1- (point)) 'face)))
      (memq f flyspell-prog-text-faces))))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
As you can see, &lt;code&gt;flyspell-generic-progmode-verify&lt;/code&gt; is very simple. If the word at point is not inside comment or string, the predicate returns nil which means the word is not a typo.
&lt;/p&gt;

&lt;p&gt;
So in theory I can write my own predicate by following &lt;code&gt;flyspell-generic-progmode-verify&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
But in reality it's not as simple as it seems. The predicate is written in Lisp so it's slow. If it contains too much code, Fly Spell process might block other actions in Emacs. Emacs could be un-responsive when editing text.
&lt;/p&gt;

&lt;p&gt;
The solution is not to start Fly Spell process too frequently.
&lt;/p&gt;

&lt;p&gt;
The &lt;code&gt;flyspell-mode&lt;/code&gt; starts checking when &lt;a href="https://github.com/emacs-mirror/emacs/blob/c6fb86b40bebf597fccbe4eba58ceea83bd9700f/lisp/textmodes/flyspell.el#L158"&gt;text in current buffer is modified&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
My solution is not to turn on &lt;code&gt;flyspell-mode&lt;/code&gt;. Instead, I manage the spell checking by myself using APIs from flyspell.
&lt;/p&gt;

&lt;p&gt;
I only spell check when user saving current buffer. The interval between spell check should not be less than 5 minutes. Spell check is done by calling API &lt;code&gt;flyspell-buffer&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Checking the whole buffer is still slow. Instead, we can check the text region in current window by calling &lt;code&gt;flyspell-region&lt;/code&gt; instead. The api &lt;code&gt;window-total-height&lt;/code&gt; returns the height of current Windows. So I can use below code to get the region to check,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(let* (beg end (orig-pos (point)))
  (save-excursion
    (forward-line (- (window-total-height)))
    (setq beg (line-beginning-position))
    (goto-char orig-pos)
    (forward-line (window-total-height))
    (setq end (line-end-position)))
  (flyspell-region beg end))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
I also need respect the predicate embedded in the major mode in my own generic predicate. Since per mode predicate has already checked the font face, I should &lt;a href="https://github.com/redguardtoo/wucuo/blob/49d2ae558068954eb8c4324b8ee7a6b2b0a00ef9/wucuo.el#L320"&gt;skip the font face check in generic predicate if per mode predicate exists&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Above algorithms are implemented in &lt;a href="https://github.com/redguardtoo/wucuo"&gt;wucuo&lt;/a&gt;. Here is its usage,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun prog-mode-hook-setup ()
  ;; (setq wucuo-flyspell-start-mode "lite")
  ;; (setq wucuo-flyspell-start-mode "ultra")
  (wucuo-start t))
(add-hook 'prog-mode-hook 'prog-mode-hook-setup)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
If &lt;code&gt;wucuo-flyspell-start-mode&lt;/code&gt; is "full" (default value), &lt;code&gt;flyspell-mode&lt;/code&gt; is enabled. In this case, wucuo is only the advanced version of &lt;code&gt;flyspell-prog-mode&lt;/code&gt;,
&lt;/p&gt;

&lt;p&gt;
If &lt;code&gt;wucuo-flyspell-start-mode&lt;/code&gt; is "lite", &lt;code&gt;flyspell-buffer&lt;/code&gt; is used, checking is done when user saves current buffer.
&lt;/p&gt;

&lt;p&gt;
If &lt;code&gt;wucuo-flyspell-start-mode&lt;/code&gt; is "ultra", &lt;code&gt;flyspell-region&lt;/code&gt; is used, checking is done when user saves current buffer.&lt;/p&gt;&lt;/div&gt;</description><category>check</category><category>emacs</category><category>en</category><category>flyspell</category><category>spell</category><guid>http://blog.binchen.org/posts/hardcore-spell-checking-in-emacs.html</guid><pubDate>Sun, 17 May 2020 06:20:55 GMT</pubDate></item><item><title>Audio recording on Linux</title><link>http://blog.binchen.org/posts/audio-recording-on-linux.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;ul class="org-ul"&gt;
&lt;li&gt;Run &lt;code&gt;sudo alsamixer&lt;/code&gt; and turn off mic to reduce the noise&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;alsamixer&lt;/code&gt; to double check pulse setup&lt;/li&gt;
&lt;li&gt;Make sure correct device is selected in &lt;a href="https://www.audacityteam.org/"&gt;audacity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Restart &lt;code&gt;audacity&lt;/code&gt; and test&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
My &lt;code&gt;alsamixer&lt;/code&gt; setup,
&lt;img src="http://blog.binchen.org/wp-content/alsamixer-nq8.png" alt="alsamixer-nq8.png"&gt;&lt;/p&gt;&lt;/div&gt;</description><category>audio</category><category>en</category><category>linux</category><guid>http://blog.binchen.org/posts/audio-recording-on-linux.html</guid><pubDate>Thu, 07 May 2020 12:04:13 GMT</pubDate></item><item><title>Use Magit API to rebase to closest branch</title><link>http://blog.binchen.org/posts/use-magit-api-to-rebase-to-closest-branch.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
My workflow in Git is,
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Create a new feature branch based on main branch&lt;/li&gt;
&lt;li&gt;Add some small commits into feature branch&lt;/li&gt;
&lt;li&gt;Rebase feature branch interactively&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The final rebase step happens a lot.
&lt;/p&gt;

&lt;p&gt;
So I could use Magit api &lt;code&gt;magit-rebase-interactive&lt;/code&gt; to speed up it.
&lt;/p&gt;

&lt;p&gt;
The key is to analyze output of &lt;code&gt;git log --decorate --oneline&lt;/code&gt; to find the main branch commit.
&lt;/p&gt;

&lt;p&gt;
Code,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun my-git-extract-based (target)
  "Extract based version from TARGET."
  (replace-regexp-in-string "^tag: +"
                            ""
                            (car (nreverse (split-string target ", +")))))

(defun my-git-rebase-interactive (&amp;amp;optional user-select-branch)
  "Rebase interactively on the closest branch or tag in git log output.
If USER-SELECT-BRANCH is not nil, rebase on the tag or branch selected by user."
  (interactive "P")
  (let* ((log-output (shell-command-to-string "git --no-pager log --decorate --oneline -n 1024"))
         (lines (split-string log-output "\n"))
         (targets (delq nil
                        (mapcar (lambda (e)
                                  (when (and (string-match "^[a-z0-9]+ (\\([^()]+\\)) " e)
                                             (not (string-match "^[a-z0-9]+ (HEAD " e)))
                                    (match-string 1 e))) lines)))
         based)
    (cond
     ((or (not targets) (eq (length targets) 0))
      (message "No tag or branch is found to base on."))
     ((or (not user-select-branch)) (eq (length targets) 1)
      ;; select the closest/only tag or branch
      (setq based (my-git-extract-based (nth 0 targets))))
     (t
      ;; select the one tag or branch
      (setq based (my-git-extract-based (completing-read "Select based: " targets)))))

    ;; start git rebase
    (when based
      (magit-rebase-interactive based nil))))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Screencast:
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/magit-rebase-api.gif" alt="magit-rebase-api.gif"&gt;
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>git</category><category>magit</category><guid>http://blog.binchen.org/posts/use-magit-api-to-rebase-to-closest-branch.html</guid><pubDate>Tue, 14 Apr 2020 13:54:28 GMT</pubDate></item><item><title>Make Emacs faster than Vim in "git mergetool"</title><link>http://blog.binchen.org/posts/make-emacs-faster-than-vim-in-git-mergetool.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
My article &lt;a href="https://blog.binchen.org/posts/emacs-is-the-best-merge-tool-for-git.html"&gt;Emacs is the best merge tool for Git&lt;/a&gt; explains how to combine &lt;a href="https://git-scm.com/docs/git-mergetool/2.20.0"&gt;git mergetool&lt;/a&gt; with &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/ediff/"&gt;ediff-mode&lt;/a&gt; in Emacs.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://disqus.com/by/harrisonmccullough/"&gt;Harrison McCullough&lt;/a&gt; suggested the work flow can be faster if emacs is replaced with emacsclient.
&lt;/p&gt;

&lt;p&gt;
I did some research and found a perfect solution. It's even faster than Vim.
&lt;/p&gt;

&lt;div id="outline-container-orgdb24522" class="outline-2"&gt;
&lt;h3 id="orgdb24522"&gt;Initial solution&lt;/h3&gt;
&lt;div class="outline-text-2" id="text-orgdb24522"&gt;
&lt;p&gt;
Please note emacsclient is only use for resolving conflicts.
&lt;/p&gt;

&lt;p&gt;
Step 1, start emacs server by running &lt;code&gt;emacs -Q --daemon --eval "(setq startup-now t)" -l "/home/my-username/.emacs.d/init.el" --eval "(progn (require 'server) (server-start))"&lt;/code&gt; in shell.
&lt;/p&gt;

&lt;p&gt;
Step 2, insert below code into &lt;code&gt;~/.emacs.d/init.el&lt;/code&gt; (see the comment why this advice is required):
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defadvice server-save-buffers-kill-terminal (after server-save-buffers-kill-terminal-after-hack activate)
  ;; kill all buffers, so new ediff panel is re-created and `ediff-startup-hook-setup' is called again
  ;; besides, remove the buffers whose binding files are alredy merged in `buffer-list'
  (mapc 'kill-buffer (buffer-list)))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Step 3, insert below code into &lt;code&gt;~/.gitconfig&lt;/code&gt;:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-ini"&gt;[mergetool.ediff]
cmd = emacsclient -nw --eval \"(progn (setq ediff-quit-hook 'kill-emacs) (if (file-readable-p \\\"$BASE\\\") (ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\") (ediff-merge-files \\\"$LOCAL\\\" \\\"$REMOTE\\\" nil \\\"$MERGED\\\")))\"
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org62b3681" class="outline-2"&gt;
&lt;h3 id="org62b3681"&gt;My real world solution&lt;/h3&gt;
&lt;div class="outline-text-2" id="text-org62b3681"&gt;
&lt;p&gt;
It's similar to initial solution. But some scripts are created for automation.
&lt;/p&gt;

&lt;p&gt;
Step 1, read &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html"&gt;Using Emacs as a Server&lt;/a&gt; in the manual and create &lt;code&gt;~/.config/systemd/user/emacs.service&lt;/code&gt; for &lt;a href="https://en.wikipedia.org/wiki/Systemd"&gt;Systemd&lt;/a&gt;:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-ini"&gt;[Unit]
Description=Emacs text editor
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=emacs -Q --daemon --eval "(setq startup-now t)" -l "/home/my-username/.emacs.d/init.el" --eval "(progn (require 'server) (server-start))" 
ExecStop=emacsclient --eval "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure

[Install]
WantedBy=default.target
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Step 2, set up in &lt;code&gt;~/.gitconfig&lt;/code&gt;:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-ini"&gt;[mergetool.emacs]
    cmd = ediff.sh "$LOCAL" "$REMOTE" "$BASE" "$MERGED"
[mergetool.emacsclient]
    cmd = MYEMACSCLIENT=emacsclient ediff.sh "$LOCAL" "$REMOTE" "$BASE" "$MERGED"
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Step 3, create &lt;code&gt;ediff.sh&lt;/code&gt;:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-sh"&gt;#!/bin/sh
[ -z "$MYEMACSCLIENT" ] &amp;amp;&amp;amp; MYEMACSCLIENT="emacs"
# emacsclient won't work in git mergetool
# $1=$LOCAL $2=$REMOTE $3=$BASE $4=$MERGED
if [ "$MYEMACSCLIENT" = "emacs" ]; then
    $MYEMACSCLIENT -nw -Q --eval "(setq startup-now t)" -l "$HOME/.emacs.d/init.el" --eval "(progn (setq ediff-quit-hook 'kill-emacs) (if (file-readable-p \"$3\") (ediff-merge-files-with-ancestor \"$1\" \"$2\" \"$3\" nil \"$4\") (ediff-merge-files \"$1\" \"$2\" nil \"$4\")))"
else
    $MYEMACSCLIENT -nw --eval "(progn (setq ediff-quit-hook 'kill-emacs) (if (file-readable-p \"$3\") (ediff-merge-files-with-ancestor \"$1\" \"$2\" \"$3\" nil \"$4\") (ediff-merge-files \"$1\" \"$2\" nil \"$4\")))"
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Step 4, run &lt;code&gt;git mergetool -t emacsclient&lt;/code&gt; to resolve conflicts.
&lt;/p&gt;

&lt;p&gt;
My &lt;a href="https://github.com/redguardtoo/emacs.d/commit/f35e749d"&gt;init-ediff.el&lt;/a&gt; in &lt;a href="https://github.com/redguardtoo/emacs.d"&gt;emacs.d&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>git</category><category>mergetool</category><guid>http://blog.binchen.org/posts/make-emacs-faster-than-vim-in-git-mergetool.html</guid><pubDate>Fri, 10 Apr 2020 09:33:40 GMT</pubDate></item><item><title>Thoughts on "Native shell completion in Emacs"</title><link>http://blog.binchen.org/posts/thoughts-on-native-shell-completion-in-emacs-emacsenautocompleteshell.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://coredumped.dev/2020/01/04/native-shell-completion-in-emacs/"&gt;Native shell completion in Emacs&lt;/a&gt; by Troy Hinckley is must read for completion in &lt;code&gt;shell-mode&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
One problem is my &lt;code&gt;~/.bashrc&lt;/code&gt; executes &lt;code&gt;/etc/bash_completion&lt;/code&gt;,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-sh"&gt;if [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Unfortunately &lt;code&gt;/etc/bash_completion&lt;/code&gt; makes &lt;code&gt;complete -p&lt;/code&gt; output some lines the Emacs function &lt;code&gt;bash-completion-tokenize&lt;/code&gt; can't analyze.
&lt;/p&gt;

&lt;p&gt;
Here is output of &lt;code&gt;complete -p&lt;/code&gt; at my PC,
&lt;/p&gt;

&lt;pre class="example"&gt;
...
complete -F _known_hosts mtr
complete -o default -o nospace -W 'homepc
192.168.1.104
github.com
gitlab.com' scp
complete -o default -f -X '!*.dvi' dvipdf
...
&lt;/pre&gt;

&lt;p&gt;
The line &lt;code&gt;gitlab.com' scp&lt;/code&gt; will crash &lt;code&gt;bash-completion-tokenize&lt;/code&gt;. Obviously, one line 
&lt;code&gt;complete -o default -o nospace -W 'homepc 192.168.1.104 github.com gitlab.com' scp&lt;/code&gt;  is wrongly split into multiple lines by &lt;code&gt;complete -p&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
In &lt;code&gt;shell-mode&lt;/code&gt;, completion functions might call &lt;code&gt;bash-completion-tokenize&lt;/code&gt;. If &lt;code&gt;bash-completion-tokenize&lt;/code&gt; crashes, the completion in &lt;code&gt;shell-mode&lt;/code&gt; won't work.
&lt;/p&gt;

&lt;p&gt;
Besides, if &lt;code&gt;company-mode&lt;/code&gt; provides auto-completion UI, it's better to place the backend &lt;code&gt;company-files&lt;/code&gt; before &lt;code&gt;company-native-complete&lt;/code&gt;. It's because the backend &lt;code&gt;company-files&lt;/code&gt; displays the full file path in candidates. So users can complete the whole path in one shot.
&lt;/p&gt;

&lt;p&gt;
My setup code for the packages Troy Hinckley suggested,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;;; Enable auto-completion in `shell'.
(with-eval-after-load 'shell
  (native-complete-setup-bash))

;; `bash-completion-tokenize' can handle garbage output of "complete -p"
(defadvice bash-completion-tokenize (around bash-completion-tokenize-hack activate)
  (let* ((args (ad-get-args 0))
         (beg (nth 0 args))
         (end (nth 1 args)))
    ;; original code extracts tokens from output of "complete -p" line by line
    (cond
     ((not (string-match-p "^complete " (buffer-substring beg end)))
      ;; filter out some wierd lines
      (setq ad-return-value nil))
     (t
      ad-do-it))))

(defun shell-mode-hook-setup ()
  "Set up `shell-mode'."
  ;; hook `completion-at-point', optional
  (add-hook 'completion-at-point-functions #'native-complete-at-point nil t)
  (setq-local company-backends '((company-files company-native-complete)))
  ;; `company-native-complete' is better than `completion-at-point'
  (local-set-key (kbd "TAB") 'company-complete))
(add-hook 'shell-mode-hook 'shell-mode-hook-setup)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Screenshot,
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/shell-complete-path-nq8.png" alt="shell-complete-path-nq8.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/shell-complete-param-nq8.png" alt="shell-complete-param-nq8.png"&gt;
&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>autocomplete</category><category>emacs</category><category>en</category><category>shell</category><guid>http://blog.binchen.org/posts/thoughts-on-native-shell-completion-in-emacs-emacsenautocompleteshell.html</guid><pubDate>Thu, 09 Apr 2020 10:40:23 GMT</pubDate></item><item><title>How to speed up lsp-mode</title><link>http://blog.binchen.org/posts/how-to-speed-up-lsp-mode.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
Here is my setup,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(with-eval-after-load 'lsp-mode
  ;; enable log only for debug
  (setq lsp-log-io nil)

  ;; use `evil-matchit' instead
  (setq lsp-enable-folding nil)

  ;; no real time syntax check
  (setq lsp-diagnostic-package :none)

  ;; handle yasnippet by myself
  (setq lsp-enable-snippet nil)

  ;; use `company-ctags' only.
  ;; Please note `company-lsp' is automatically enabled if installed
  (setq lsp-enable-completion-at-point nil)

  ;; turn off for better performance
  (setq lsp-enable-symbol-highlighting nil)

  ;; use ffip instead
  (setq lsp-enable-links nil)

  ;; auto restart lsp
  (setq lsp-restart 'auto-restart)

  ;; @see https://github.com/emacs-lsp/lsp-mode/pull/1498 and code related to auto configure.
  ;; Require clients could be slow.
  ;; I only load `lsp-clients' because it includes the js client which I'm interested
  (setq lsp-client-packages '(lsp-clients))

  ;; don't scan 3rd party javascript libraries
  (push "[/\\\\][^/\\\\]*\\.\\(json\\|html\\|jade\\)$" lsp-file-watch-ignored) ; json

  ;; don't ping LSP lanaguage server too frequently
  (defvar lsp-on-touch-time 0)
  (defadvice lsp-on-change (around lsp-on-change-hack activate)
    ;; don't run `lsp-on-change' too frequently
    (when (&amp;gt; (- (float-time (current-time))
                lsp-on-touch-time) 30) ;; 30 seconds
      (setq lsp-on-touch-time (float-time (current-time)))
      ad-do-it)))

(defun my-connect-lsp (&amp;amp;optional no-reconnect)
  "Connect lsp server.  If NO-RECONNECT is t, don't shutdown existing lsp connection."
  (interactive "P")
  (when (and (not no-reconnect)
             (fboundp 'lsp-disconnect))
    (lsp-disconnect))
  (when (and buffer-file-name
             (not (member (file-name-extension buffer-file-name)
                          '("json"))))
    (unless (and (boundp 'lsp-mode) lsp-mode)
      (if (derived-mode-p 'js2-mode) (setq-local lsp-enable-imenu nil))
      (lsp-deferred))))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
To enable &lt;code&gt;lsp&lt;/code&gt; for the major mode &lt;code&gt;XXX-mode&lt;/code&gt; needs only one line,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(add-hook 'XXX-mode-hook #'my-connect-lsp)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
You also need install three packages,
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://github.com/redguardtoo/counsel-etags"&gt;counsel-etags&lt;/a&gt; for code navigation&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/redguardtoo/company-ctags"&gt;company-ctags&lt;/a&gt; for code completion&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/technomancy/find-file-in-project"&gt;find-file-in-project&lt;/a&gt; (ffip) for searching file in project&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Explanation,
&lt;/p&gt;

&lt;p&gt;
Ctags is used to generate tags file for &lt;code&gt;company-ctags&lt;/code&gt; and &lt;code&gt;counsel-etags&lt;/code&gt;. GNU Find is required for &lt;code&gt;find-file-in-project&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
These three packages are faster and can replace the corresponding functionalities in &lt;code&gt;lsp-mode&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
I don't need any lint tools from &lt;code&gt;lsp-mode&lt;/code&gt; because the lint tool is already included in our build script. I can see the syntax error from terminal.
&lt;/p&gt;

&lt;p&gt;
I &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html"&gt;advice&lt;/a&gt; the &lt;code&gt;lsp-on-change&lt;/code&gt; in order to notify the language server less frequently.
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;js2-mode&lt;/code&gt;  has its own javascript parser extract imenu items. So I don't need javascript language server's parser to send back imenu items.
&lt;/p&gt;

&lt;p&gt;
By default &lt;code&gt;lsp-client-packages&lt;/code&gt; contains many clients, but I only code in javascript which is included in &lt;code&gt;lsp-clients&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Here is code &lt;a href="https://github.com/emacs-lsp/lsp-mode/blob/00766ad62dbe679631b8361b9b26fd3d663bb6ba/lsp-mode.el#L7156"&gt;quoted from lsp-mode&lt;/a&gt;,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;;;;###autoload
(defun lsp (&amp;amp;optional arg)
  ;; ...
  (when (and lsp-auto-configure)
    (seq-do (lambda (package) (require package nil t))
            lsp-client-packages))
  ;; ...
)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
I have done &lt;a href="https://github.com/emacs-lsp/lsp-mode/pull/1498"&gt;some profiling&lt;/a&gt; by insert &lt;code&gt;(profiler-report-cpu)&lt;/code&gt; at the end of &lt;code&gt;lsp&lt;/code&gt; (the bottlenecks is highlighted).
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/lsp-mode-bottleneck-nq8.png" alt="lsp-mode-bottleneck-nq8.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
The language server I used &lt;a href="https://github.com/sourcegraph/javascript-typescript-langserver/issues/394"&gt;can read jsconfig.json&lt;/a&gt; in project root. I can specify the directories to exclude in it.&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><guid>http://blog.binchen.org/posts/how-to-speed-up-lsp-mode.html</guid><pubDate>Mon, 09 Mar 2020 12:10:32 GMT</pubDate></item><item><title>Yin and Yang in Emacs</title><link>http://blog.binchen.org/posts/yin-and-yang-in-emacs.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
As a Chinese, I studied &lt;a href="https://en.wikipedia.org/wiki/Tao_Te_Ching"&gt;Tao Te Ching&lt;/a&gt; since childhood. So I believe Tao (the way) exist in Emacs. Tao is basically Yin and Yang who lives in harmony in Emacs.
&lt;/p&gt;

&lt;p&gt;
I can't say Yin is good and Yang is evil, or vice versa. All I can do is to find the way to make Yin and Yang co-exist. 
&lt;/p&gt;

&lt;p&gt;
For example, a few days ago I published &lt;a href="https://www.reddit.com/r/emacs/comments/dz2a80/effective_git_blame_in_emacs/"&gt;Effective "git blame" in Emacs&lt;/a&gt; which introduced my package &lt;a href="https://github.com/redguardtoo/vc-msg"&gt;vc-msg&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
It became one of my most popular reddit post because its unique feature &lt;b&gt;partial line blame&lt;/b&gt;,
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/vc-msg-good.png" alt="vc-msg-good.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/vc-msg-bad.png" alt="vc-msg-bad.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
I noticed some comments compared my package with &lt;a href="https://magit.vc/"&gt;Magit&lt;/a&gt;. Those comments were very educational and I did learn a few useful tricks.
&lt;/p&gt;

&lt;p&gt;
My point is, &lt;code&gt;vc-msg&lt;/code&gt; and &lt;code&gt;Magit&lt;/code&gt; could collaborate without any problem, like Yin and Yang lives harmony. If you find any conflict between &lt;code&gt;vc-msg&lt;/code&gt; and &lt;code&gt;Magit&lt;/code&gt;, just let me know. I will fix it.
&lt;/p&gt;

&lt;p&gt;
I totally understand there are many Magit lovers in Emacs community. So I make &lt;code&gt;vs-msg v1.0.2&lt;/code&gt; to support Magit. You can use &lt;code&gt;partial line blame&lt;/code&gt; in &lt;code&gt;vc-msg&lt;/code&gt; but calling Magit command to open the commit.  
&lt;/p&gt;

&lt;p&gt;
It's only one line setup,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(setq vc-msg-git-show-commit-function 'magit-show-commit)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/vc-msg-and-magit.png" alt="vc-msg-and-magit.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
I tested in &lt;code&gt;magit-blame-mode&lt;/code&gt; and found no issue.
&lt;/p&gt;

&lt;p&gt;
I'm sure &lt;code&gt;vc-msg&lt;/code&gt; should work in other major modes or minor modes. There are also two callback functions &lt;code&gt;vc-msg-get-current-file-function&lt;/code&gt; and &lt;code&gt;vc-msg-get-line-num-function&lt;/code&gt; which users can customize.&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><guid>http://blog.binchen.org/posts/yin-and-yang-in-emacs.html</guid><pubDate>Mon, 25 Nov 2019 08:09:33 GMT</pubDate></item><item><title>Effective "git blame" in Emacs</title><link>http://blog.binchen.org/posts/effective-git-blame-in-emacs.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
I published Emacs package &lt;a href="https://github.com/redguardtoo/vc-msg"&gt;vc-msg&lt;/a&gt;. It uses &lt;code&gt;git-blame&lt;/code&gt; to show commit information of current line.
&lt;/p&gt;

&lt;p&gt;
In the new version, it can display the correct commit information of current line.
&lt;/p&gt;

&lt;p&gt;
For example, the line 6 at &lt;a href="https://github.com/redguardtoo/test-git-blame/blob/master/hello.js"&gt;https://github.com/redguardtoo/test-git-blame/blob/master/hello.js&lt;/a&gt; is changed by three commits.
&lt;/p&gt;

&lt;p&gt;
Select the partial of line 6 and run &lt;code&gt;vc-msg-show&lt;/code&gt;, the correct commit is displayed.
&lt;/p&gt;

&lt;p&gt;
Screenshots,
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/vc-msg-neutral.png" alt="vc-msg-neutral.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/vc-msg-good.png" alt="vc-msg-good.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/vc-msg-bad.png" alt="vc-msg-bad.png"&gt;
&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>blame</category><category>emacs</category><category>en</category><category>git</category><guid>http://blog.binchen.org/posts/effective-git-blame-in-emacs.html</guid><pubDate>Wed, 20 Nov 2019 13:42:54 GMT</pubDate></item><item><title>Emacs is the best merge tool for Git</title><link>http://blog.binchen.org/posts/emacs-is-the-best-merge-tool-for-git.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
CREATED: &lt;span class="timestamp-wrapper"&gt;&lt;span class="timestamp"&gt;&amp;lt;2019-11-13 Wed&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;
UPDATED: &lt;span class="timestamp-wrapper"&gt;&lt;span class="timestamp"&gt;&amp;lt;2020-04-10 Fri&amp;gt; &lt;/span&gt;&lt;/span&gt; if you use my solution, you can &lt;a href="http://blog.binchen.org/posts/make-emacs-faster-than-vim-in-git-mergetool.html"&gt;replace emacs with emacsclient&lt;/a&gt;. So it's even &lt;b&gt;faster than Vim&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
I used to regard vimdiff as the best merge tool for Git because it's simply fast.
&lt;/p&gt;

&lt;p&gt;
Here is the demo how I use vimdiff to resolve conflicts from &lt;a href="https://github.com/redguardtoo/test-git-mergetool"&gt;https://github.com/redguardtoo/test-git-mergetool&lt;/a&gt;.
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/vimdiff-as-git-merge-tool.gif" alt="vimdiff-as-git-merge-tool.gif"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Please note in the screencast I use Git built in command &lt;a href="https://git-scm.com/docs/git-mergetool"&gt;mergetool&lt;/a&gt;. It will &lt;b&gt;automatically&lt;/b&gt; open conflicted file one by one using vim. In other software, the developer need &lt;b&gt;manually&lt;/b&gt; select and open the conflicted file. 
&lt;/p&gt;

&lt;p&gt;
The only issue is Vim is not as powerful as Emacs.
&lt;/p&gt;

&lt;p&gt;
Resolving conflicts is NOT only picking up a diff hunk from remote/local buffer. I often need place my hunk into merged buffer first, then I go to remote buffer and copy some snippet into merged buffer. So there are lots of sub-window operations.
&lt;/p&gt;

&lt;p&gt;
In Emacs, I use &lt;a href="https://github.com/abo-abo/ace-window"&gt;Ace-window&lt;/a&gt; and &lt;a href="https://github.com/deb0ch/emacs-winum"&gt;Winum&lt;/a&gt; to move focus between sub-windows.  I also use API &lt;code&gt;window-configuration-to-register&lt;/code&gt; and &lt;code&gt;jump-to-register&lt;/code&gt; to save/load windows layout. Besides, &lt;a href="https://www.gnu.org/software/emacs/manual/html_mono/ediff.html"&gt;Ediff&lt;/a&gt; is a beast to handle diff and patch.
&lt;/p&gt;

&lt;p&gt;
So I give one example to prove why Emacs should be a better merge tool &lt;b&gt;in theory&lt;/b&gt;. If you are good at both Vim and Emacs, you know it's the truth.
&lt;/p&gt;

&lt;p&gt;
Now let's talk the real world problem. And I will show you a perfect solution soon.
&lt;/p&gt;

&lt;p&gt;
The problem is, I never use Emacs to resolve merge conflicts for two reasons:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;First, &lt;a href="https://github.com/redguardtoo/emacs.d"&gt;My Emacs configuration&lt;/a&gt; uses too many packages. It starts up slowly. As you can see from vimdiff demo, &lt;code&gt;git mergetool&lt;/code&gt; restarts the editor many times. So the editor should be lightweight.&lt;/li&gt;
&lt;li&gt;Second, the UI of &lt;code&gt;ediff&lt;/code&gt; is not right. UI of Vimdiff is much better. All operations should be completed freely in any sub-window instead of ediff control panel only.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Luckily, Emacs gives me the full freedom to solve the problem. The final result is beyond my expectation.
&lt;/p&gt;

&lt;p&gt;
Here is the complete solution.
&lt;/p&gt;

&lt;div id="outline-container-orgc0eb2f1" class="outline-2"&gt;

&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
This technique is only useful for &lt;code&gt;git mergetool&lt;/code&gt; because git will open and close the text editor Emacs many times.
&lt;/p&gt;

&lt;p&gt;
Insert below code into &lt;code&gt;~/.gitconfig&lt;/code&gt;,
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-ini"&gt;[mergetool.ediff]
# use git mergetool ediff to resolve conflicts
cmd = emacs -nw -Q --eval \"(setq startup-now t)\" -l \"~/.emacs.d/init.el\" --eval \"(progn (setq ediff-quit-hook 'kill-emacs) (if (file-readable-p \\\"$BASE\\\") (ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\") (ediff-merge-files \\\"$LOCAL\\\" \\\"$REMOTE\\\" nil \\\"$MERGED\\\")))\"
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
In above code, option &lt;code&gt;-Q&lt;/code&gt; equals &lt;code&gt;-q --no-site-file --no-splash&lt;/code&gt;. Actually, only &lt;code&gt;-q&lt;/code&gt; is critical. &lt;code&gt;-q&lt;/code&gt; means "Do not load an init file". A global emacs lisp flag &lt;code&gt;startup-now&lt;/code&gt; is defined before loading &lt;code&gt;~/.emacs.d/init.el&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Then in &lt;code&gt;~/.emacs.d/init.el&lt;/code&gt;, I need only add one line,
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(when (not (boundp 'startup-now))
  ;; heavy weight configuration happens here
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
When &lt;code&gt;startup-now&lt;/code&gt; is defined, all the heavyweight configuration should be off. Considering in this scenario, we are using Emacs only as merge tool, 99% configuration could be turned off. For example, set up for any programming language is not required. Flyspell and flycheck should be off. Yasnippet is also useless. 
&lt;/p&gt;

&lt;p&gt;
I only need focus on essential operations related to text/file/window.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://github.com/emacs-evil/evil"&gt;Evil&lt;/a&gt; should be used. At the beginning of this article, I said "I love vimdiff because it's fast". It's impossible to be more efficient without Evil.
&lt;/p&gt;

&lt;p&gt;
Any patch/diff utilities should be included too. &lt;a href="https://github.com/abo-abo/swiper"&gt;counsel/swiper/ivy&lt;/a&gt; is also must have because I can use &lt;code&gt;counsel-git&lt;/code&gt; to find file and &lt;code&gt;counsel-git-grep&lt;/code&gt; to grep text.
&lt;/p&gt;

&lt;p&gt;
Native Emacs API is enough to save/load windows layout.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6072b85" class="outline-2"&gt;

&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
Packages dependent on ediff (&lt;a href="https://magit.vc/"&gt;Magit&lt;/a&gt;?) could also benefit from optimization of ediff.
&lt;/p&gt;

&lt;p&gt;
The optimization is simple. Do everything in merged buffer.
&lt;/p&gt;

&lt;p&gt;
First I move focus into merged buffer when Emacs starts up,
&lt;/p&gt;

&lt;p&gt;
This set up happens in &lt;code&gt;ediff-startup-hook&lt;/code&gt;, 
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun ediff-startup-hook-setup ()
  ;; hide control panel if it's current buffer
  (when (string-match-p (setq my-ediff-panel-name (buffer-name))
                        "\*Ediff Control Panel.*\*")
    ;; move to the first difference
    (ediff-next-difference)
    ;; move to the merged buffer window
    (winum-select-window-by-number 3)
    ;; save the windows layout
    (window-configuration-to-register ?a)))

(add-hook 'ediff-startup-hook 'ediff-startup-hook-setup)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;
&lt;p&gt;
Please note I use &lt;code&gt;winum-select-window-by-number&lt;/code&gt; from &lt;code&gt;winum&lt;/code&gt; move focus to merged buffer. You can use any other third party package or native API &lt;code&gt;select-window&lt;/code&gt; instead.
&lt;/p&gt;

&lt;p&gt;
Saving initial windows layout into register &lt;code&gt;a&lt;/code&gt; is achieved by &lt;code&gt;(window-configuration-to-register ?a)&lt;/code&gt; in &lt;code&gt;ediff-startup-hook&lt;/code&gt;. &lt;code&gt;(jump-to-register ?a)&lt;/code&gt; restores the saved layout.
&lt;/p&gt;

&lt;p&gt;
Then we need make sure ediff commands can be used out of ediff's panel. Currently ediff command can only be triggered inside of its panel.
&lt;/p&gt;

&lt;p&gt;
The trick is "move focus into ediff panel temporarily to execute its commands, then move focus back to original window".
&lt;/p&gt;

&lt;p&gt;
So I designed a macro &lt;code&gt;my-ediff-command&lt;/code&gt; to do this,
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defmacro my-ediff-command (cmd &amp;amp;optional no-arg)
  `(lambda (&amp;amp;optional arg)
     (interactive "P")
     (let* ((w (get-buffer-window)))
       ;; go to panel window
       (select-window (get-buffer-window my-ediff-panel-name))
       ;; execute ediff command, ignore any error
       (condition-case e
           (if ,no-arg (funcall ,cmd) (funcall ,cmd arg))
         (error
          (message "%s" (error-message-string e))))
       ;; back to original window
       (select-window w))))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Usage is simple,
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(global-set-key (kbd "C-c C-y") (my-ediff-command 'ediff-next-difference))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Here is the list of essential ediff commands,
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;ediff-next-difference&lt;/li&gt;
&lt;li&gt;ediff-previous-difference&lt;/li&gt;
&lt;li&gt;ediff-restore-diff-in-merge-buffer&lt;/li&gt;
&lt;li&gt;ediff-revert-buffers-then-recompute-diffs&lt;/li&gt;
&lt;li&gt;ediff-copy-A-to-C&lt;/li&gt;
&lt;li&gt;ediff-copy-A-to-C&lt;/li&gt;
&lt;li&gt;ediff-copy-both-to-C&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
You can use &lt;a href="https://github.com/abo-abo/hydra"&gt;Hyra&lt;/a&gt; or &lt;a href="https://github.com/noctuid/general.el"&gt;General.el&lt;/a&gt; to assign key bindings.
&lt;/p&gt;

&lt;p&gt;
The definition of &lt;code&gt;ediff-copy-both-to-C&lt;/code&gt;,
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;;; @see https://stackoverflow.com/a/29757750/245363
(defun ediff-copy-both-to-C (&amp;amp;optional arg)
  "Copy code from both A and B to C."
  (interactive)
  (ediff-copy-diff ediff-current-difference nil 'C nil
                   (concat
                    (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                    (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Here is &lt;a href="https://gist.github.com/redguardtoo/d4ecd51f785bd117a6a0"&gt;my ~/.gitconfig&lt;/a&gt; and &lt;a href="https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-ediff.el"&gt;my ediff set up&lt;/a&gt; in real world.
&lt;/p&gt;

&lt;p&gt;
Please note the techniques introduced here &lt;b&gt;can be used with other VCS (subversion, perforce â€¦)&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
Demo on using Emacs to resolve merge conflicts,
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/emacs-as-git-merge-tool.gif" alt="emacs-as-git-merge-tool.gif"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>git</category><category>mergetool</category><guid>http://blog.binchen.org/posts/emacs-is-the-best-merge-tool-for-git.html</guid><pubDate>Wed, 13 Nov 2019 13:29:46 GMT</pubDate></item><item><title>counsel-etags 1.9.0 is out</title><link>http://blog.binchen.org/posts/counsel-etags-1-9-0-is-out.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://github.com/redguardtoo/counsel-etags"&gt;Counsel-etags&lt;/a&gt; is fast, energy-saving, and powerful code navigation solution.
&lt;/p&gt;

&lt;p&gt;
This version can list tags in current buffer.
&lt;/p&gt;

&lt;p&gt;
You can simply run &lt;code&gt;M-x counsel-etags-list-tag-in-current-file&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Or set up imenu before &lt;code&gt;M-x imenu&lt;/code&gt; or &lt;code&gt;M-x helm-imenu&lt;/code&gt; or &lt;code&gt;M-x counsel-imenu&lt;/code&gt;, 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(setq imenu-create-index-function 'counsel-etags-imenu-default-create-index-function)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
screenshot:
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/counsel-etags-imenu.png" alt="counsel-etags-imenu.png"&gt;
&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><guid>http://blog.binchen.org/posts/counsel-etags-1-9-0-is-out.html</guid><pubDate>Sun, 27 Oct 2019 12:38:05 GMT</pubDate></item></channel></rss>